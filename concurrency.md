# 需要考虑并发的场景探讨

## 1. 资料

[高并发的哲学原理](https://pphc.lvwenhan.com/)

## 2. 场景

我们以生产者消费者模型来进行类比  
假如 有一个 **顾客(消费者)** 来到一家饭店吃饭，由 **厨师(生产者)** 给他做  

**顾客方面**:  
由于顾客实在太饿了，他得吃 1000 道满汉全席。但是除了厨房他还有其他一堆的事要去做  

**厨师方面**:
厨师不可能一下子全端上来，不然整个餐馆放不下

此时会出现两种情况(假设厨师烧的菜份量一样)

### 2.1 厨师烧的太慢了，刚端上来，菜就吃完了，接下来 顾客 要接着等下一道满汉全席

**类比**：IO 准备数据太慢，拖慢了整个系统的运行速度
**解决思路**：先让顾客去忙其他的事，厨师去后厨(后台) 烧菜，但是顾客如何知道什么时候可以吃饭了呢？

1. 顾客在整条街上逛，每逛一次都 **看看** 厨师有没有做好，做好就吃饭，没做好就接着逛
2. 在上一个例子中，我们假设，只有当 顾客 吃完后，厨师才去做下一份，这次我们换种准备方式  
顾客在整条街上逛，每逛一次都 **看看** 厨师有没有做好，厨师不语，只是一味的做菜，放到空闲的位置上，顾客吃完后，需要自己去拿下一份  
如果吃完了发现下一份还没做好，就去外面做别的事
3. 顾客在整条街上逛，不过他已经将电话留给了厨师，厨师一烧好就给他打电话，吃完就去干别的事了，等待下一个电话

**现实方案**:

1. 轮询 select/poll
2. 事件回调 epoll
3. 协程: 用同步的方式编写异步的代码
4. 缓存机制

### 2.2 厨师烧的太快了，这盘还没吃完，下一盘又来了，顾客 根本吃不过来

**类比**: 硬件性能不足，CPU 满载运行，不能及时处理数据，导致积压
**解决思路**: 开启多重影分身，这样就能以 n 倍的速度去吃饭了

**现实方案**: 多线程/多进程

### 2.3 分库分表？

### 2.4 视频流 和 大规模用户请求

## 3. [TODO] 项目 demo

### 3.1 模拟大规模请求 并处理

#### 3.1.0 模拟大规模请求

#### 3.1.1 用 轮询处理

1. select/poll
2. epoll

#### 3.1.2 用 中断 处理

1. 系统编程？

#### 3.1.3 用 协程处理

1. rust async/await
2. kotlin coroutine

#### 3.1.4 用 多线程处理

1. rust multi thread

### 3.2 用 回调函数 封装 select/poll/epoll

1. 参考 libuv
2. libuv 的回调地狱

### 3.3 数据库与大规模数据读写

#### 3.3.1 使用场景

#### 3.3.2 数据模拟 与 压力测试
