# 一些项目的想法

## 0. 提前声明

### 0.1 有关屠龙术

为什么这份文档里没有那些高大上的技术，比如架构，消息队列，分布式，高并发这些东西  
首先我们要明白一个叫做 **屠龙术** 的概念  
这个概念指那些 **理论上强大** 但 **实际应用** 中因 *过于复杂* 或 *脱离现实需求* 而难以落地的技术或工具。它常被用来调侃某些​​“高深但无用”​​的技术，就像传说中的屠龙术——学了一身杀龙的本事，却发现世界上根本 **没有龙** 可杀

同样的，我自己接触不到使用这些技术的场景，大厂又不需要我，让他们自己卷去吧  
再说这些技术的核心思想压根就没变，只不过新瓶装旧酒，完全可以类比已有的技术  
如果你非要学这些东西的话，你问下自己，你打算用在什么场景上(或是你打算如何模拟呢)，你打算去哪买硬件呢？云平台？如果是工业自动化那类的编程呢？哪种机器就别想了吧？

#### 0.1.1 举个 lisp 语言的例子

**Lisp：理论上的“终极语言”​​**
​​优势​​:

1. 近乎无限的抽象能力（宏系统、代码即数据）  
2. 函数式编程范式的先驱（闭包、高阶函数）  
3. 强大的动态性和交互式开发（REPL）  

**​​为何是“屠龙术”？​​**  

1. ​​学习曲线陡峭​​：S-表达式、递归思维、宏的复杂性让多数开发者望而却步
2. ​​生态局限​​：工业界更倾向用 Java/Python 等务实语言，Lisp 长期局限于学术或小众领域（如 Emacs 配置、AI 研究）
3. ​​性能与工程化​​：动态类型和垃圾回收在早期硬件上效率低，难以支撑大型工程

#### 0.1.2 Ada 语言

**Ada：军工级的“完美语言”​​**
​​优势​​：

1. 强类型、契约式设计（前置/后置条件）。
2. 内置并发模型（Task 和 Protected Object）。
3. 为高可靠性系统设计（航空、航天、医疗）。

**​​为何是屠龙术**  

1. ​​过度设计​​：语法繁琐（如 end loop_name;），开发效率低。
2. ​​应用场景狭窄​​：主要用于军工、航天等特定领域，普通业务开发用不到其严格性。
3. ​​生态封闭​​：工具链和社区支持远不如 C/C++/Rust。

### 0.2 屠龙术是分场合的

我要指明的是，这里的 **屠龙术** 不是绝对的，他的错误指的是 **技术** 与 **场景** 的错误配对，并不是指技术的优劣，我们需要通过场景和时代去判断屠龙术

#### 0.2.1 Lisp 的宏系统​​

​​对普通业务开发​​：过度抽象，如同“屠龙术”（无龙可屠）。
​​对编译器设计或DSL开发​​：是刚需（龙真实存在）。

#### 0.2.2 Ada 的强类型​​

​​对电商网站​​：繁琐冗余（杀鸡用牛刀
​​对航天控制软件​​：是保命手段（龙是系统崩溃）

#### 0.2.3 在计算机发展初期出现的技术

​​垃圾回收​​: Lisp 在 1958 年引入时被视为低效，如今是 Java/Python 的基础功能  
​​函数式编程​​: 同样从 Lisp 中来，但现代语言（如 Swift/Kotlin）大量吸收其思想

#### 0.2.4 C 语言 vs. 内存安全语言：时代需求的变化

1. **1970s-1990s（C 的黄金时代）**  
   • **硬件资源少，需要极致性能** → C 统治操作系统、嵌入式开发。  
   • **安全不是重点**，软件规模小，漏洞影响有限。  

2. **2000s-2010s（内存安全危机）**  
   • **互联网爆发，软件复杂度激增** → C 的内存错误（如缓冲区溢出）导致大量漏洞。  
   • **Java/Python/Go 崛起**，用 GC 或自动管理内存，牺牲少量性能换安全。  

3. **2020s 以后（安全成为刚需）**  
   • **云计算、AI、法规要求高可靠性** → Rust 成 C 的替代者（无 GC 且内存安全）。  
   • **C 仍用于底层开发**（如 Linux 内核），但新项目优先选 Rust/Go。  

## 1. 有关项目

项目一定要代码够多吗？并不是，以下是基于我的个人经验
做一个项目的时候，最重要的不是写代码，而是确定需求  
一个项目中最重要的是其核心功能，其他的代码都是关于 **输入，输出，错误处理** ，还有为了代码可维护性实行的 **模块化编程** 等其他东西  
我听说 Linux 内核源码核心功能只占很小一部分，其他的大部分都是驱动代码

## 2. [重要] 有关代码

以前我的学习方式是，找一个代码量比较少的仓库，然后对着这些代码，自己手敲一遍，慢慢就理解了  
这种方式虽然比阅读源码好那么一点，但是太费精力了，要是编程语言不相同，还硬要抄的话，好多函数的功能在我这边是不需要的，比如手动内存管理  
还有些代码，就像进了脏东西一样，没有他就运行不了

现在的话，一个项目里你掌握了核心代码的思路就行了，剩下的需要你自己实现并学习

## 3. 可以参考的资料

在这些链接中我经常找项目做，你也可以看看

1. [project-based-learning](https://github.com/practical-tutorials/project-based-learning?tab=readme-ov-file)
2. [build your own x](https://github.com/codecrafters-io/build-your-own-x)
3. [app-ideas](https://github.com/florinpop17/app-ideas)

## 4. (可以到这个章节上贡献) 这个仓库中的内容

| 想法名称 | 作者 | 阶段 | 仓库地址|
|:--: | :--: | :--: |
| [需要考虑并发的场景探讨](./concurrency.md)| @kurt-steiner | 需要确认项目细节 | null |
| [简单的web全栈项目](./web-fullstack.md) | @kurt-steiner | 需要确认项目细节 | null |
| [markdown 语法解析器](./markdown-parser.md) | @kurt-steiner | 在我本地上开发，还未完成代码和文档 | null |
| [org-mode 语法解析器](./org-mode-parser.md) | @kurt-steiner | 还未开始，等待 markdown 解析器开发完成| null|
| [用 Kotlin DSL 描述一个 Makefile 文件](./makefile-dsl.md) | @kurt-steiner | 还未开始 | null |
| [做一个 ORM 框架 using Java](./orm.md) | @kurt-steiner |  still working | [check this](https://github.com/aurora-learning-communicating/make-a-orm) |
